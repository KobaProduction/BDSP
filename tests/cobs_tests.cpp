#include <gtest/gtest.h>

#include <BDSP/streams/COBS/reader.h>
#include <BDSP/streams/COBS/writer.h>

#include "utils/cobs.h"
#include "utils/show.h"
#include "utils/testing.h"

using namespace BDSP::streams;

TEST(cobs_pipelines_tests, cobs_utils_test) {
    std::vector<uint8_t> data;
    std::vector<uint8_t> encoded;
    std::vector<uint8_t> decoded;

    for (int i = 0; i < 512; ++i) {
        data.push_back(i);
    }
    cobs_encode(data, encoded);
    cobs_decode(encoded, decoded);
    if (is_equals(data, decoded)) {
        return;
    }
    std::cout << "Correct ";
    show_data(data);
    std::cout << "Encoded ";
    show_data(encoded);
    std::cout << "Decoded ";
    show_data(decoded);
    FAIL() << "the correct and encoded array is not equal";
}

TEST(cobs_pipelines_tests, encoding_default_test) {
    COBS::COBSWriter cobs_writer;

    std::vector<uint8_t> data;
    std::vector<uint8_t> correct_encoded;

    for (int size = 1; size < 1000; ++size) {
        data.clear();
        correct_encoded.clear();

        for (int i = 0; i < size; ++i) {
            data.push_back(i);
        }
        cobs_encode(data, correct_encoded);
        start_test_writer(cobs_writer, data, correct_encoded);
    }
}

TEST(cobs_pipelines_tests, decoding_test) {
    COBS::COBSReader cobs_reader;

    std::vector<uint8_t> data;
    std::vector<uint8_t> encoded;

    for (int size = 1; size < 1000; ++size) {
        data.clear();
        encoded.clear();
        for (int i = 0; i < size; ++i) {
            data.push_back(i);
        }
        cobs_encode(data, encoded);
        start_test_reader(cobs_reader, encoded, data);
    }
}

TEST(cobs_pipelines_tests, encoding_custom_delimiter_test) {
    COBS::cobs_config_t config = {.delimiter = '\n'};
    COBS::COBSWriter cobs_writer;
    cobs_writer.set_config(config);
    COBS::COBSReader cobs_reader;
    cobs_reader.set_config(config);

    struct Context {
        std::vector<uint8_t> data;
        std::vector<uint8_t> encoded;
        std::vector<uint8_t> decoded;
        bool is_ended = false;
    } ctx;

    cobs_writer.set_stream_writer(
        [](uint8_t byte, void *ctx) { reinterpret_cast<Context *>(ctx)->encoded.push_back(byte); }, &ctx);

    cobs_reader.set_stream_data_handler(
        [](uint8_t byte, read_status_t status, void *ctx) {
            auto &context = *reinterpret_cast<Context *>(ctx);
            ASSERT_FALSE(context.is_ended);
            if (status == READ_OK)
                context.decoded.push_back(byte);
            if (status == READ_END)
                context.is_ended = true;
        },
        &ctx);

    for (int size = 1; size < 1000; ++size) {
        ctx.data.clear();
        ctx.encoded.clear();
        ctx.decoded.clear();

        for (int i = 0; i < size; ++i) {
            ctx.data.push_back(i);
        }
        cobs_writer.write(ctx.data.data(), ctx.data.size());
        cobs_writer.finish();
        cobs_reader.read(ctx.encoded.data(), ctx.encoded.size());
        ASSERT_TRUE(is_equals(ctx.data, ctx.decoded));
        ASSERT_TRUE(ctx.is_ended);
        ctx.is_ended = false;
    }
}

TEST(cobs_pipelines_tests, cobs_with_sequence_replacement_test) {
    COBS::cobs_config_t config = {.delimiter = 0, .size_of_the_sequence_to_be_replaced = 2};
    COBS::COBSWriter cobs_writer;
    cobs_writer.set_config(config);
    COBS::COBSReader cobs_reader;
    cobs_reader.set_config(config);

    std::vector<uint8_t> data = {0x00, 0x00, 0x00, 0x01};
    std::vector<uint8_t> correct_encoded = {128, 0x01, 0x02, 0x01, 0x00};
    start_test_writer(cobs_writer, data, correct_encoded);
    //    start_test_reader(cobs_reader,correct_encoded, data);
}

TEST(cobs_pipelines_tests, cobs_with_zero_pair_elimination_article_test) {
    COBS::COBSZPEWriter cobs_writer;
    COBS::COBSZPEReader cobs_reader;

    std::vector<uint8_t> data = {0x45, 0x00, 0x00, 0x2C, 0x4C, 0x79, 0x00, 0x00, 0x40, 0x06, 0x4F, 0x37};
    ;
    std::vector<uint8_t> correct_encoded = {0xE2, 0x45, 0xE4, 0x2C, 0x4C, 0x79, 0x05, 0x40, 0x06, 0x4F, 0x37, 0x00};
    start_test_writer(cobs_writer, data, correct_encoded, true);
    start_test_reader(cobs_reader, correct_encoded, data, true);
}

TEST(cobs_pipelines_tests, cobs_with_zero_pair_elimination_full_test) {
    COBS::COBSZPEWriter cobs_writer;
    COBS::COBSZPEReader cobs_reader;

    std::vector<uint8_t> data = {
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0x45, 0x00, 0x00, 0x2C, 0x4C, 0x79, 0x00, 0x00, 0x40, 0x06, 0x4F, 0x37};

    std::vector<uint8_t> correct_encoded = {
        0xE0, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xE2, 0x45, 0xE4, 0x2C, 0x4C, 0x79, 0x05, 0x40, 0x06, 0x4F, 0x37, 0x00};

    start_test_writer(cobs_writer, data, correct_encoded, true);
    start_test_reader(cobs_reader, correct_encoded, data, true);
}